#include <pthread.h>
#include <vector>
#include <iostream>
#include <map>
#include <list>
#include <queue>
#include <tuple>
#include <string>
#include <fstream>
#include <sstream>
#include <algorithm>

using namespace std;

struct thread_data
{
    queue<tuple<string, size_t>> *file_queue;
    pthread_mutex_t *mutex;
    pthread_barrier_t *barrier;
    pthread_cond_t *cond;
    vector<map<string, vector<size_t>>> *thread_map_result;
    map<string, priority_queue<size_t, vector<size_t>, greater<size_t>>> *global_result;
    map <char, vector<tuple<string, vector<size_t>>>> *group_result;
    bool is_merged;
    int thread_id;
    int num_map_threads;
    int num_reduce_threads;
};

void remove_unwanted_chars(string &word) {
    string new_word = "";

    for (int i = 0; i < word.size(); i++) {
        if (isalpha(word[i])) {
            new_word += tolower(word[i]);
        }
    }

    word = new_word;
}

map<string, size_t>  map_function(tuple<string, size_t> file) {
    string line;
    map<string, size_t> local_result;

    size_t file_id = get<1>(file);
    string input_file = get<0>(file);

    ifstream fin(input_file);

    if (fin.is_open()) {
        while(getline(fin, line)) {
            // Process line

            stringstream ss(line);
            vector<string> words;
            string  word;

            while (ss >> word) {
                words.push_back(word);
            }

            for (string &word : words) {
                remove_unwanted_chars(word);

                if (word.size() > 0) {
                    if (local_result.find(word) == local_result.end()) {
                        local_result[word] = file_id;
                    }
                }
            }
        }
    }
    fin.close();

    return local_result;
}

bool sort_by_entry(const tuple<string, vector<size_t>> &a, const tuple<string, vector<size_t>> &b) {
    if (get<1>(a).size() == get<1>(b).size()) {
        return get<0>(a) < get<0>(b);
    } else {
        return get<1>(a).size() > get<1>(b).size();
    }
}

void reduce_function(thread_data *data) {

    // Group by first letter from global_result
    int start = (data->thread_id - data->num_map_threads) * 26 / data->num_reduce_threads;
    int end = min((data->thread_id - data->num_map_threads + 1) * 26 / data->num_reduce_threads, 26);

    for (int i = start; i < end; i++) {
        char c = 'a' + i;
        vector<tuple<string, vector<size_t>>> group;

        for (auto &entry : *data->global_result) {
            if (entry.first[0] == c) {
                group.push_back(make_tuple(entry.first, vector<size_t>()));

                while (!entry.second.empty()) {
                    get<1>(group.back()).push_back(entry.second.top());
                    entry.second.pop();
                }
            }
        }

        sort(group.begin(), group.end(), sort_by_entry);

        (*data->group_result)[c] = group;
    }
}




void *thread_function(void *arg) {
    thread_data *data = (thread_data *)arg;

    if (data->thread_id < data->num_map_threads) {
        // Map

        while(true) {
            tuple<string, size_t> file;

            // Get file
            pthread_mutex_lock(data->mutex);

            if (data->file_queue->empty()) {
                pthread_mutex_unlock(data->mutex);
                break;
            } else {
                file = data->file_queue->front();
                data->file_queue->pop();
                pthread_mutex_unlock(data->mutex);
            }

            map<string, size_t> local_result = map_function(file);

            // Add to thread result
            // for (auto &entry : local_result) {
            //     if ((*data->thread_map_result)[data->thread_id].find(entry.first) == (*data->thread_map_result)[data->thread_id].end()) {
            //         (*data->thread_map_result)[data->thread_id][entry.first] = vector<size_t>();
            //     }

            //     (*data->thread_map_result)[data->thread_id][entry.first].push_back(entry.second);
            // }

            pthread_mutex_lock(data->mutex);

            // Add to global result
            for (auto &entry : local_result) {
                if (data->global_result->find(entry.first) == data->global_result->end()) {
                    (*data->global_result)[entry.first] = priority_queue<size_t, vector<size_t>, greater<size_t>>();
                }

                (*data->global_result)[entry.first].push(entry.second);
            }

            pthread_mutex_unlock(data->mutex); 
        }

        pthread_barrier_wait(data->barrier);
    } else {
        // Reduce
        pthread_barrier_wait(data->barrier);

        // Merge thread_map_result into global_result (single thread)
        
        // pthread_mutex_lock(data->mutex);

        // if (!data->is_merged) {
        //     for (int i = 0; i < data->num_map_threads; i++) {
        //         for (auto &entry : (*data->thread_map_result)[i]) {
        //             string word = entry.first;
        //             vector<size_t> &file_ids = entry.second;

        //             if (data->global_result->empty()) {
        //                 data->global_result->push_back(make_tuple(word, file_ids));
        //             } else {
        //                 bool found = false;

        //                 for (auto &global_entry : *data->global_result) {
        //                     if (get<0>(global_entry) == word) {
        //                         found = true;
        //                         vector<size_t> &global_file_ids = get<1>(global_entry);

        //                         for (size_t file_id : file_ids) {
        //                             if (find(global_file_ids.begin(), global_file_ids.end(), file_id) == global_file_ids.end()) {
        //                                 global_file_ids.push_back(file_id);
        //                             }
        //                         }

        //                         break;
        //                     }
        //                 }

        //                 if (!found) {
        //                     data->global_result->push_back(make_tuple(word, file_ids));
        //                 }
        //             }
        //         }
        //     }

        //     // sort global_result tuple second element
        //     for (auto &entry : *data->global_result) {
        //         sort(get<1>(entry).begin(), get<1>(entry).end());
        //     }


        //     data->is_merged = true;
        //     pthread_cond_broadcast(data->cond);
        // } else {
        //     while (!data->is_merged) {
        //         pthread_cond_wait(data->cond, data->mutex);
        //     }
        // }

        // pthread_mutex_unlock(data->mutex);

        reduce_function(data);
    }
    return NULL;
}

size_t getFileSize(const string& filename) {
    ifstream file(filename, ios::ate);
    if (!file.is_open()) {
        cout << "Cannot open file " << filename << endl;
        return 0;
    }
    return file.tellg();
}

bool sort_by_file_size(const tuple<string, size_t, size_t> &a, const tuple<string, size_t, size_t> &b) {
    return get<1>(a) < get<1>(b);
}

queue<tuple<string, size_t>> get_files(string input_file) {
    list<tuple<string, size_t, size_t>> file_list;
    string line;
    size_t id = 1;
    ifstream fin(input_file);

    if (fin.is_open()) {
        getline(fin, line);
        while(getline(fin, line)) {
            file_list.push_back(make_tuple(line, getFileSize(line), id));
            id++;
        }
    }
    fin.close();    

    file_list.sort(sort_by_file_size);

    queue<tuple<string, size_t>> file_queue;
    for (auto &file : file_list) {
        file_queue.push(make_tuple(get<0>(file), get<2>(file)));
    }

    return file_queue;
}

void write_output(map <char, vector<tuple<string, vector<size_t>>>> &group_result) {
    for (char c = 'a'; c <= 'z'; c++) {
        ofstream fout(string(1, c) + ".txt");

        if (group_result.find(c) != group_result.end()) {
            for (auto &entry : group_result[c]) {
                fout << get<0>(entry) << ":[";
                sort(get<1>(entry).begin(), get<1>(entry).end());
                for (size_t file_id : get<1>(entry)) {
                    if (file_id != get<1>(entry).back()) {
                        fout << file_id << " ";
                    } else {
                        fout << file_id;
                    }
                }
                fout << "]" << endl;
            }
        } else {
            fout << endl;
        }

        fout.close();
    }
}

int main(int argc, char **argv)
{
    if (argc < 4)
    {
        cout << argv[0] << " <Map_num_threads> <Reduce_num_threads> <input_file>" << endl;
        return 1;
    }

    int num_map_threads = atoi(argv[1]);
    int num_reduce_threads = atoi(argv[2]);
    string input_file = argv[3];
    queue<tuple<string, size_t>> file_queue = get_files(input_file);

    vector<map<string, vector<size_t>>> thread_map_result(num_map_threads);
    map <char, vector<tuple<string, vector<size_t>>>> group_result;
    map<string, priority_queue<size_t, vector<size_t>, greater<size_t>>> global_result;
    
    vector<pthread_t> threads(num_map_threads + num_reduce_threads);
    vector<thread_data> thread_data_list(num_map_threads + num_reduce_threads);

    pthread_mutex_t mutex;
    pthread_mutex_init(&mutex, NULL);

    pthread_barrier_t barrier;
    pthread_barrier_init(&barrier, NULL, num_map_threads + num_reduce_threads);

    pthread_cond_t cond;
    pthread_cond_init(&cond, NULL);
    bool is_merged = false;
    

    // Create threads
    for (int i = 0; i < num_map_threads + num_reduce_threads; i++) {

        thread_data_list[i].file_queue = &file_queue;
        thread_data_list[i].mutex = &mutex;
        thread_data_list[i].barrier = &barrier;
        thread_data_list[i].cond = &cond;
        thread_data_list[i].thread_map_result = &thread_map_result;
        thread_data_list[i].group_result = &group_result;
        thread_data_list[i].global_result = &global_result;
        thread_data_list[i].is_merged = is_merged;
        thread_data_list[i].thread_id = i;
        thread_data_list[i].num_map_threads = num_map_threads;
        thread_data_list[i].num_reduce_threads = num_reduce_threads;

        pthread_create(&threads[i], NULL, thread_function, &thread_data_list[i]);
    }

    // Join threads
    for (int i = 0; i < num_map_threads + num_reduce_threads; i++) {
        pthread_join(threads[i], NULL);
    }

    // Write output
    write_output(group_result);

    // print global result
    // for (auto &entry : global_result) {
    //     cout << get<0>(entry) << ":[";
    //     sort(get<1>(entry).begin(), get<1>(entry).end());
    //     for (size_t file_id : get<1>(entry)) {
    //         if (file_id != get<1>(entry).back()) {
    //             cout << file_id << " ";
    //         } else {
    //             cout << file_id;
    //         }
    //     }
    //     cout << "]" << endl;
    // }

    // print gouped result
    // for (char c = 'a'; c <= 'z'; c++) {
    //     if (group_result.find(c) != group_result.end()) {
    //         cout << c << endl;
    //         for (auto &entry : group_result[c]) {
    //             cout << get<0>(entry) << ":[";
    //             sort(get<1>(entry).begin(), get<1>(entry).end());
    //             for (size_t file_id : get<1>(entry)) {
    //                 if (file_id != get<1>(entry).back()) {
    //                     cout << file_id << " ";
    //                 } else {
    //                     cout << file_id;
    //                 }
    //             }
    //             cout << "]" << endl;
    //         }
    //     } else {
    //         cout << c << endl;
    //     }
    // }

    pthread_mutex_destroy(&mutex);
    pthread_barrier_destroy(&barrier);

    return 0;
}